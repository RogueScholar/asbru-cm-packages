Description: Add whatis entries to the pod files
 Also corrected spelling in UniqueMessageData.xs per lintian
Author: Ryan Niebur <ryan@debian.org>
Forwarded: https://rt.cpan.org/Public/Bug/Display.html?id=95016
Reviewed-by: Peter J. Mello <admin@petermello.net>
Last-Update: 2019-06-09

--- a/xs/UniqueApp.xs
+++ b/xs/UniqueApp.xs
@@ -57,6 +57,9 @@
 
 }
 
+=for object Gtk2::UniqueApp a single instance application
+
+=cut
 
 MODULE = Gtk2::UniqueApp  PACKAGE = Gtk2::UniqueApp  PREFIX = unique_app_
 
--- a/xs/UniqueBackend.xs
+++ b/xs/UniqueBackend.xs
@@ -16,6 +16,9 @@
 
 =cut
 
+=for object Gtk2::UniqueBackend IPC backend used by libunique
+
+=cut
 
 =for apidoc
 
--- a/xs/Unique.xs
+++ b/xs/Unique.xs
@@ -7,6 +7,10 @@
 
 MODULE = Gtk2::Unique  PACKAGE = Gtk2::Unique  PREFIX = unique_
 
+=for object Gtk2::Unique Use single instance applications
+
+=cut
+
 PROTOTYPES: DISABLE
 
 
--- a/xs/UniqueMessageData.xs
+++ b/xs/UniqueMessageData.xs
@@ -18,7 +18,7 @@
 What's important to understand is that a C<Gtk2::MessageData> is a generic
 container for all message types (text, data, filename and uris). There's no way
 to query what kind of message a C<Gtk2::MessageData> holds. It is the
-responsability of each application to know it in advance and to call the proper
+responsibility of each application to know it in advance and to call the proper
 get methods. If you don't call the proper get method you could have a
 segmentation fault in your application as the C library will try to unmarshall
 the message with the wrong code.
